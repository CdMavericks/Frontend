<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Student Face Enrollment</title>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

  <!-- External CSS -->
  <link rel="stylesheet" href="styles.css" />
</head>

<body class="faceid-bg">
  <div class="ui-shell">
    <!-- Cancel (top-left) -->
    <button id="cancel-btn" class="cancel-btn">Cancel</button>

    <h1 class="title">Face Enrollment</h1>
    <p id="instruction-text" class="instruction">Loading AI Model...</p>

    <div class="stage" id="stage">
      <div class="video-wrap">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="circle_canvas"></canvas>
        <div class="vignette"></div>
      </div>
    </div>

    <canvas id="snap_canvas"></canvas>

    <p class="caption">Captured Images</p>
    <div id="photo-preview-bar" class="preview-bar">
      <!-- Previews will be added here -->
    </div>

    <div class="done-wrap">
      <button id="done-btn" class="done-btn hidden">Done</button>
    </div>
  </div>

  <!-- Firebase SDK + Face Enrollment Logic -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBujiz5R1qEHcLvlMp9fQIViIMuWs3gRZk",
      authDomain: "cam-attendance-a4881.firebaseapp.com",
      projectId: "cam-attendance-a4881",
      storageBucket: "cam-attendance-a4881.appspot.com",
      messagingSenderId: "344849505667",
      appId: "1:344849505667:web:9a8ddb0a009f458fca2ab6",
      measurementId: "G-RLBS140J6Y",
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);

    // ELEMENTS
    const videoEl = document.getElementById('video');
    const circleCanvas = document.getElementById('circle_canvas');
    const snapCanvas = document.getElementById('snap_canvas');
    const instr = document.getElementById('instruction-text');
    const previewBar = document.getElementById('photo-preview-bar');
    const cancelBtn = document.getElementById('cancel-btn');
    const doneBtn = document.getElementById('done-btn');

    const ctx = circleCanvas.getContext('2d', { alpha: true });
    const snapCtx = snapCanvas.getContext('2d');

    const captured = {};
    let currentPose = null;
    let lastSnapAt = 0;
    const SNAP_COOLDOWN_MS = 900;
    const poses = {
      frontal: { label: 'Move your head slowly to complete the circle', captured: false },
      left: { label: 'Look Left', captured: false },
      right: { label: 'Look Right', captured: false },
      up: { label: 'Look Up', captured: false },
      down: { label: 'Look Down', captured: false }
    };
    const poseOrder = ['frontal', 'left', 'right', 'up', 'down'];

    let cssW = 0, cssH = 0, dpr = window.devicePixelRatio || 1;
    function resizeCanvas() {
      const rect = circleCanvas.getBoundingClientRect();
      if (!rect) return;
      cssW = rect.width;
      cssH = rect.height;
      dpr = window.devicePixelRatio || 1;
      circleCanvas.width = Math.round(cssW * dpr);
      circleCanvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    requestAnimationFrame(resizeCanvas);

    function draw(progressAngle = 0) {
      ctx.clearRect(0, 0, cssW, cssH);
      const cx = cssW / 2, cy = cssH / 2;
      if (cx === 0 || cy === 0) return;
      const radius = Math.min(cssW, cssH) * 0.42;

      ctx.beginPath();
      ctx.arc(cx, cy, radius + 6, 0, Math.PI * 2);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.stroke();

      if (progressAngle > 0) {
        ctx.beginPath();
        ctx.arc(cx, cy, radius, -Math.PI / 2, -Math.PI / 2 + progressAngle, false);
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#32ff85';
        ctx.shadowBlur = 6;
        ctx.shadowColor = 'rgba(50,255,133,0.8)';
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else {
        ctx.beginPath();
        ctx.arc(cx, cy, radius, -Math.PI / 2, Math.PI * 3 / 2);
        ctx.lineWidth = 6;
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.stroke();
      }

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, cssW, cssH);
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(cx, cy, radius * 0.96, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function loop() {
      const progress = (Object.keys(captured).length / poseOrder.length) * Math.PI * 2;
      draw(progress);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function snap(poseName) {
      if (!videoEl.videoWidth || !videoEl.videoHeight) return;
      if (poses[poseName].captured) return;
      const now = Date.now();
      if (now - lastSnapAt < SNAP_COOLDOWN_MS) return;
      lastSnapAt = now;

      poses[poseName].captured = true;
      const vW = videoEl.videoWidth, vH = videoEl.videoHeight;
      snapCanvas.width = vW;
      snapCanvas.height = vH;
      snapCtx.save();
      snapCtx.translate(vW, 0);
      snapCtx.scale(-1, 1);
      snapCtx.drawImage(videoEl, 0, 0, vW, vH);
      snapCtx.restore();

      const dataUrl = snapCanvas.toDataURL('image/jpeg', 0.9);
      captured[poseName] = dataUrl;
      const img = document.createElement('img');
      img.src = dataUrl;
      img.className = 'preview-thumb';
      previewBar.appendChild(img);

      instr.textContent = "Captured ✔";
      setTimeout(() => {
        let next = null;
        for (const p of poseOrder) if (!poses[p].captured) { next = p; break; }
        if (next) { currentPose = next; instr.textContent = poses[currentPose].label; }
        else {
          currentPose = 'DONE';
          instr.textContent = 'Enrollment Complete';
          stopCamera();
          doneBtn.classList.remove('hidden');
        }
      }, 700);
    }

    function detectPoseFromLandmarks(lm) {
      if (!lm || lm.length === 0) return null;
      const leftEye = lm[130], rightEye = lm[359], forehead = lm[10], chin = lm[152];
      const yaw = leftEye.z - rightEye.z;
      const pitch = forehead.z - chin.z;
      const YAW_THRESHOLD = 0.035, PITCH_THRESHOLD = 0.035;

      if (yaw > YAW_THRESHOLD * 1.5) return 'right';
      if (yaw < -YAW_THRESHOLD * 1.5) return 'left';
      if (pitch > PITCH_THRESHOLD * 1.2) return 'up';
      if (pitch < -PITCH_THRESHOLD * 1.2) return 'down';
      if (Math.abs(yaw) < 0.02 && Math.abs(pitch) < 0.02) return 'frontal';
      return null;
    }

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1, refineLandmarks: true,
      minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
    });

    faceMesh.onResults((res) => {
      if (!res.multiFaceLandmarks || res.multiFaceLandmarks.length === 0) {
        if (currentPose !== 'DONE' && currentPose !== 'frontal') {
          instr.textContent = "Face not detected. Please look straight.";
        }
        return;
      }
      if (currentPose === 'DONE') return;
      const lm = res.multiFaceLandmarks[0];
      const detected = detectPoseFromLandmarks(lm);
      if (!currentPose) {
        currentPose = 'frontal';
        instr.textContent = poses[currentPose].label;
      }
      if (detected === currentPose && !poses[currentPose].captured) snap(currentPose);
    });

    let camera = null;
    async function startCamera() {
      try {
        camera = new Camera(videoEl, {
          onFrame: async () => { await faceMesh.send({ image: videoEl }); },
          width: 480, height: 480
        });
        await camera.start();
        currentPose = 'frontal';
        instr.textContent = poses[currentPose].label;
        resizeCanvas();
      } catch (e) { instr.textContent = 'Camera error: ' + e.message; }
    }

    function stopCamera() {
      try {
        if (camera && camera.stop) camera.stop();
        if (videoEl.srcObject) {
          const s = videoEl.srcObject;
          if (s.getTracks) s.getTracks().forEach(t => t.stop());
          videoEl.srcObject = null;
        }
      } catch (e) { }
    }

    cancelBtn.addEventListener('click', () => {
      stopCamera();
      instr.textContent = 'Enrollment cancelled';
    });
    // ... (keep the existing variable and function definitions above)

    // Ensure this variable is defined near the top with your other constants
    const BACKEND_URL = "http://localhost:5000/enroll"; // The URL of your Node.js endpoint
    doneBtn.addEventListener('click', async () => {
      const userId = localStorage.getItem('currentUserUid');
      const email = localStorage.getItem('currentUserEmail');

      // Safety check to ensure data exists before proceeding
      if (!userId || !email) {
        instr.textContent = '❌ Error: Login details are missing. Please re-login.';
        return;
      }

      // Extract USN and convert to uppercase
      let usn = email.slice(0, 10).toUpperCase();

      // Use the backend URL constant
      const BACKEND_URL = "http://localhost:5000/enroll";

      instr.textContent = "Uploading images and saving enrollment data...";

      try {
        // STEP 1: Send base64 images and user data to Node.js backend
        const backendRes = await fetch(BACKEND_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: userId, // Firebase UID (DB Primary Key)
            usn: usn,       // Extracted USN (New DB column)
            // Send the captured base64 images to the server
            images: Object.values(captured)
          }),
        });

        const result = await backendRes.json();

        // STEP 2: Handle response from the backend
        if (result.status === 'success') {
          instr.textContent = '✅ Enrollment saved successfully to Database!';
          console.log("Backend response:", result);
        } else {
          // Log the specific error message from the server
          instr.textContent = '❌ Database Save Failed: ' + (result.error || 'Check server logs');
          console.error("Backend Error:", result);
        }

      } catch (err) {
        // This catches connection failures (like ERR_CONNECTION_REFUSED)
        console.error("Enrollment process error:", err);
        instr.textContent = "❌ Error connecting to server: " + err.message;
      }
    });

    // doneBtn.addEventListener('click', async () => {
    //   instr.textContent = 'Uploading to Cloudinary...';
    //   const userId = localStorage.getItem('currentUserUid');
    //   const email = localStorage.getItem('currentUserEmail');
    //   let usn = email.slice(0, 10).toUpperCase();
    //   if (!userId || !email) {
    //     instr.textContent = '❌ Error: Login details are missing. Please re-login.';
    //     return;
    //   }

    //   // *** STEP 1: Cloudinary Setup ***
    //   const CLOUD_NAME = "dk0lzipwv";
    //   const UPLOAD_PRESET = "face_enroll_unsigned";
    //   const uploadedUrls = {};
    //   //const userId = "magic_user_001"; // <<< Use a consistent hardcoded ID for testing (Primary Key)

    //   try {
    //     // Upload each image from the captured object to Cloudinary
    //     for (const [poseName, base64Image] of Object.entries(captured)) {
    //       const res = await fetch(base64Image);
    //       const blob = await res.blob();

    //       const formData = new FormData();
    //       formData.append("file", blob);
    //       formData.append("upload_preset", UPLOAD_PRESET);
    //       // It's recommended to use the userId in the folder name for organization
    //       formData.append("folder", `face_enrollments/${userId}`);

    //       const uploadRes = await fetch(
    //         `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/image/upload`,
    //         { method: "POST", body: formData }
    //       );

    //       const data = await uploadRes.json();
    //       uploadedUrls[poseName] = data.secure_url;
    //       console.log(`✅ Uploaded ${poseName}:`, data.secure_url);
    //     }

    //     // *** STEP 2: Send All URLs to your Node.js Backend ***
    //     instr.textContent = "Saving enrollment data...";

    //     // Prepare the array of URLs in the correct order for the backend
    //     const imagesForBackend = [
    //       uploadedUrls.frontal,
    //       uploadedUrls.left,
    //       uploadedUrls.right,
    //       uploadedUrls.up,
    //       uploadedUrls.down,
    //     ];

    //     // This is the call that interacts with your server.js and MySQL
    //     const backendRes = await fetch(BACKEND_URL, {
    //       method: "POST",
    //       headers: { "Content-Type": "application/json" },
    //       body: JSON.stringify({
    //         userId: userId,
    //         usn: usn,
    //         // The backend expects an 'images' array of base64 strings,
    //         // but since you did the Cloudinary upload here, we need to adapt 
    //         // the backend OR change the backend to accept 'urls' instead.
    //         // Since the backend expects 'images' with base64, we will 
    //         // revert to sending the base64 data to the backend for the original
    //         // server.js to handle the Cloudinary upload.
    //         //
    //         // *************************************************************
    //         // REVERTING TO ORIGINAL BACKEND STRATEGY for simplicity:
    //         // Send the captured base64 images, let the backend upload them.
    //         // *************************************************************
    //         images: Object.values(captured)
    //       }),
    //     });

    //     const result = await backendRes.json();

    //     if (result.status === 'success') {
    //       instr.textContent = '✅ Enrollment saved successfully to Database!';
    //       console.log("Backend response:", result);
    //     } else {
    //       instr.textContent = '❌ Database Save Failed: ' + (result.error || 'Check server logs');
    //       console.error("Backend Error:", result);
    //     }

    //   } catch (err) {
    //     console.error("Enrollment process error:", err);
    //     instr.textContent = "❌ Error in enrollment process: " + err.message;
    //   }
    // });

    startCamera();
  </script>
</body>

</html>